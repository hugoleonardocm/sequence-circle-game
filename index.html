<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Círculos Sequenciais</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            color: #fff;
            padding: 10px;
            overflow-x: hidden;
        }
        
        h1 {
            margin: 10px 0;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            text-align: center;
        }
        
        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 500px;
        }
        
        select, button {
            padding: 8px 12px;
            font-size: clamp(0.9rem, 3vw, 1rem);
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #333;
            color: #fff;
        }
        
        button {
            background-color: #2a6e2d;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            padding: 8px 16px;
        }
        
        button:hover {
            background-color: #3a8e3d;
        }
        
        button:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            aspect-ratio: 4/3;
            border: 2px solid #444;
            background-color: #000;
            overflow: hidden;
            margin: 0 auto;
            touch-action: none; /* Previne comportamentos de toque padrão */
        }
        
        .circle {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #8fe88f;
            cursor: pointer;
            background-color: transparent;
            border: 2px solid rgba(76, 175, 80, 0.7);
            z-index: 10;
            pointer-events: none; /* Desativa cliques no círculo menor */
            transition: opacity 0.3s, transform 0.3s;
            font-size: clamp(0.8rem, 3vw, 1.2rem);
        }
        
        .countdown-circle {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(76, 175, 80, 0.6);
            background-color: transparent;
            z-index: 5;
            cursor: pointer; /* Torna o círculo maior clicável */
            transition: opacity 0.3s, transform 0.3s;
        }
        
        /* Destacar o próximo círculo que deve ser clicado */
        .countdown-circle.next {
            border: 2px solid rgba(255, 255, 100, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
            z-index: 6; /* Prioridade mais alta para o próximo círculo */
        }
        
        /* Desativar círculos que não devem ser clicados ainda */
        .countdown-circle.inactive {
            pointer-events: none;
            opacity: 0.5;
        }
        
        .result-indicator {
            position: absolute;
            font-weight: bold;
            font-size: clamp(1rem, 3vw, 1.5rem);
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
        }
        
        .perfect {
            color: gold;
        }
        
        .good {
            color: #8fe88f;
        }
        
        .miss {
            color: #ff6b6b;
        }
        
        .line {
            position: absolute;
            background-color: rgba(76, 175, 80, 0.4);
            z-index: 1;
            transform-origin: 0 0;
        }
        
        .score-info {
            margin-top: 15px;
            font-size: clamp(1rem, 3vw, 1.2rem);
            color: #fff;
            text-align: center;
        }
        
        .instruction {
            margin: 10px 0;
            font-style: italic;
            color: #aaa;
            max-width: 800px;
            text-align: center;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            padding: 0 10px;
        }
        
        .game-over, .success-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: clamp(1.5rem, 5vw, 2rem);
            text-align: center;
            padding: 20px;
        }
        
        .game-over span {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            margin-top: 20px;
        }
        
        .game-over button, .success-overlay button {
            margin-top: 20px;
            font-size: clamp(1rem, 3vw, 1.2rem);
            padding: 10px 20px;
        }
        
        /* Estilo para o overlay de sucesso */
        .success-overlay {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .success-overlay .title {
            color: gold;
            font-size: clamp(1.8rem, 6vw, 2.5rem);
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .success-overlay .message {
            color: #8fe88f;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            margin: 5px 0;
        }
        
        /* Media queries para responsividade */
        @media (max-width: 768px) {
            #game-container {
                aspect-ratio: 3/4; /* Formato mais alto que largo para mobile */
            }
            
            .controls {
                flex-direction: column;
                gap: 8px;
            }
            
            select, button {
                width: 100%;
                max-width: 300px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            #game-container {
                border-width: 1px;
            }
            
            .circle, .countdown-circle {
                border-width: 1px;
            }
        }
        
        /* Melhorias para desktop */
        @media (min-width: 1200px) {
            #game-container {
                aspect-ratio: 4/3;
                max-height: 70vh;
            }
        }
        
        /* Modo paisagem em dispositivos móveis */
        @media (max-width: 768px) and (orientation: landscape) {
            body {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                align-items: flex-start;
                padding: 5px;
            }
            
            h1 {
                width: 100%;
                margin: 5px 0;
            }
            
            .controls-wrapper {
                display: flex;
                flex-direction: column;
                width: 20%;
                margin-right: 10px;
            }
            
            #game-container {
                width: 75%;
                aspect-ratio: 5/3;
                margin: 0;
            }
            
            .score-info, .instruction {
                width: 100%;
                margin: 5px 0;
            }
        }

        /* Prevenção de scroll e zoom em dispositivos móveis */
        @media (hover: none) and (pointer: coarse) {
            body {
                touch-action: pan-x pan-y;
                height: 100%;
                position: fixed;
                overflow: hidden;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Training room</h1>
    
    <div class="instruction">
        Clique no círculo destacado quando ele se alinhar com o círculo interno! Você deve clicar nos círculos em ordem numérica.
    </div>
    
    <div class="controls-wrapper">
        <div class="controls">
            <select id="level-select">
                <option value="easy">Fácil</option>
                <option value="medium">Médio</option>
                <option value="hard">Difícil</option>
                <option value="expert">Especialista</option>
                <option value="insane">Insano</option>
            </select>
            <button id="start-button">Iniciar</button>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <div class="score-info">
        Pontuação: <span id="score">0</span>
    </div>
    
    <script>
        // Configurações do jogo
        const config = {
            easy: {
                circleCount: 10,
                spawnDelay: 1000,
                timeToClick: 2000,
                hitZoneTolerance: 0.30
            },
            medium: {
                circleCount: 15,
                spawnDelay: 750,
                timeToClick: 1500,
                hitZoneTolerance: 0.25
            },
            hard: {
                circleCount: 20,
                spawnDelay: 600,
                timeToClick: 1200,
                hitZoneTolerance: 0.20
            },
            expert: {
                circleCount: 25,
                spawnDelay: 500,
                timeToClick: 1000,
                hitZoneTolerance: 0.15
            },
            insane: {
                circleCount: 30,
                spawnDelay: 300,
                timeToClick: 600,
                hitZoneTolerance: 0.10
            }
        };
        
        // Variáveis do jogo
        let gameRunning = false;
        let currentLevel;
        let currentNumber = 0;
        let nextClickNumber = 1;
        let score = 0;
        let lastCirclePos = null;
        let circleElements = [];
        let lineElements = [];
        let countdownTimers = [];
        let activeCircles = {};
        let spawnTimer = null;
        let isMobile = window.matchMedia("(max-width: 768px)").matches;
        
        // Referências aos elementos do DOM
        const gameContainer = document.getElementById('game-container');
        const levelSelect = document.getElementById('level-select');
        const startButton = document.getElementById('start-button');
        const scoreElement = document.getElementById('score');
        
        // Carregar sons usando o Web Audio API para melhor compatibilidade
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Função para calcular tamanho dos círculos com base no contêiner
        function calculateCircleSize() {
            const containerWidth = gameContainer.offsetWidth;
            const containerHeight = gameContainer.offsetHeight;
            const smallerDimension = Math.min(containerWidth, containerHeight);
            
            // Tamanho base para cada nível, agora como porcentagem do contêiner
            const baseSize = smallerDimension * (isMobile ? 0.12 : 0.075);
            
            // Retorna o tamanho calculado
            return baseSize;
        }
        
        // Função para tocar som
        function playSound(buffer) {
            if (!buffer || !audioContext) return;
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
        }
        
        // Criar som de batida de porta (toc toc) - SUAVIZADO
        function createKnockSound() {
            if (!audioContext || !gameRunning) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 180;
            gainNode.gain.value = 0.15;
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            setTimeout(() => oscillator.stop(), 100);
        }
        
        // Som de sucesso suavizado
        function createSuccessSound() {
            if (!audioContext || !gameRunning) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 120;
            gainNode.gain.value = 0.15;
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            setTimeout(() => oscillator.stop(), 200);
        }
        
        // Som de falha mais suave
        function createFailSound() {
            if (!audioContext || !gameRunning) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine'; 
            oscillator.frequency.value = 220;
            gainNode.gain.value = 0.15;
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            oscillator.frequency.linearRampToValueAtTime(180, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            setTimeout(() => oscillator.stop(), 300);
        }
        
        // Som de celebração para conclusão de nível
        function createCelebrationSound() {
            if (!audioContext || !gameRunning) return;
            
            const playChord = (baseFreq, time, duration) => {
                const notes = [1, 1.25, 1.5];
                
                notes.forEach(interval => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * interval;
                    gain.gain.value = 0.1;
                    
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                    gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + time + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + time + duration);
                    
                    osc.start(audioContext.currentTime + time);
                    osc.stop(audioContext.currentTime + time + duration);
                });
            };
            
            playChord(440, 0, 0.3);
            playChord(523.25, 0.25, 0.3);
            playChord(659.25, 0.5, 0.6);
        }
        
        // Prevenir comportamentos padrão de toque em dispositivos móveis
        function preventDefaultTouchBehavior() {
            document.addEventListener('touchmove', function(e) {
                if (gameRunning) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchstart', function(e) {
                if (gameRunning && e.target.closest('#game-container')) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Iniciar o jogo
        function startGame() {
            // Iniciar contexto de áudio se necessário
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Reset do jogo
            resetGame();
            
            // Configurar o nível
            currentLevel = config[levelSelect.value];
            
            // Marcar o jogo como em execução
            gameRunning = true;
            startButton.disabled = true;
            
            // Redefinir o número para o próximo clique
            nextClickNumber = 1;
            
            // Iniciar o spawn de círculos
            spawnCircle();
        }
        
        // Resetar o jogo
        function resetGame() {
            gameContainer.innerHTML = '';
            circleElements = [];
            lineElements = [];
            currentNumber = 0;
            nextClickNumber = 1;
            score = 0;
            scoreElement.textContent = score;
            lastCirclePos = null;
            activeCircles = {};
            
            // Limpar todos os timers
            countdownTimers.forEach(timer => clearTimeout(timer));
            countdownTimers = [];
            if (spawnTimer) clearTimeout(spawnTimer);
        }
        
        // Função para atualizar o destaque visual do próximo círculo
        function updateCircleHighlights() {
            // Remover todos os destaques
            document.querySelectorAll('.countdown-circle').forEach(circle => {
                circle.classList.remove('next', 'inactive');
            });
            
            // Adicionar destaque ao próximo círculo e desativar os outros
            document.querySelectorAll('.countdown-circle').forEach(circle => {
                const circleNumber = parseInt(circle.dataset.number);
                if (circleNumber === nextClickNumber) {
                    circle.classList.add('next');
                } else if (circleNumber > nextClickNumber) {
                    circle.classList.add('inactive');
                }
            });
        }
        
        // Gerar um círculo
        function spawnCircle() {
            if (!gameRunning) return;
            
            // Calcular tamanho do círculo com base no tamanho do contêiner
            const circleSize = calculateCircleSize();
            
            currentNumber++;
            
            // Posição aleatória (com margem para o círculo caber na tela)
            const margin = circleSize;
            const x = margin + Math.random() * (gameContainer.offsetWidth - 2 * margin);
            const y = margin + Math.random() * (gameContainer.offsetHeight - 2 * margin);
            
            // Criar círculo principal
            const circle = document.createElement('div');
            circle.className = 'circle';
            circle.style.width = circleSize + 'px';
            circle.style.height = circleSize + 'px';
            circle.style.left = (x - circleSize / 2) + 'px';
            circle.style.top = (y - circleSize / 2) + 'px';
            circle.textContent = currentNumber;
            circle.dataset.number = currentNumber;
            gameContainer.appendChild(circle);
            circleElements.push(circle);
            
            // Criar círculo de contagem regressiva (agora clicável)
            const countdownCircle = document.createElement('div');
            countdownCircle.className = 'countdown-circle';
            // Adicionar classe 'inactive' se não for o próximo a ser clicado
            if (currentNumber !== nextClickNumber) {
                countdownCircle.classList.add('inactive');
            } else {
                countdownCircle.classList.add('next');
            }
            
            const countdownSize = circleSize * 2.5;
            countdownCircle.style.width = countdownSize + 'px';
            countdownCircle.style.height = countdownSize + 'px';
            countdownCircle.style.left = (x - countdownSize / 2) + 'px';
            countdownCircle.style.top = (y - countdownSize / 2) + 'px';
            countdownCircle.dataset.number = currentNumber;
            
            // Adicionar eventos para desktop e mobile
            countdownCircle.addEventListener('click', handleCircleClick);
            countdownCircle.addEventListener('touchstart', handleCircleClick, { passive: false });
            
            gameContainer.appendChild(countdownCircle);
            
            // Registrar círculo ativo
            activeCircles[currentNumber] = {
                startTime: Date.now(),
                duration: currentLevel.timeToClick,
                element: circle,
                countdownElement: countdownCircle,
                position: { x, y },
                progress: 0,
                clicked: false,
                size: circleSize
            };
            
            // Desenhar linha
            if (lastCirclePos) {
                drawLine(lastCirclePos.x, lastCirclePos.y, x, y);
            }
            
            // Salvar posição atual para a próxima linha
            lastCirclePos = { x, y };
            
            // Iniciar animação de contagem regressiva
            animateCountdown(currentNumber);
            
            // Tocar som de batida inicial
            createKnockSound();
            
            // Agendar o próximo círculo se não for o último
            if (currentNumber < currentLevel.circleCount) {
                spawnTimer = setTimeout(spawnCircle, currentLevel.spawnDelay);
            } else {
                // Todos os círculos foram gerados, aguardar finalização
                spawnTimer = setTimeout(() => {
                    if (gameRunning) {
                        endGame(true);
                    }
                }, currentLevel.timeToClick + 1000);
            }
        }
        
        // Animar o círculo de contagem regressiva
        function animateCountdown(circleNumber) {
            if (!activeCircles[circleNumber] || !gameRunning) return;
            
            const circleData = activeCircles[circleNumber];
            const now = Date.now();
            const elapsed = now - circleData.startTime;
            const progress = Math.min(elapsed / circleData.duration, 1);
            
            circleData.progress = progress;
            
            if (progress < 1 && !circleData.clicked) {
                // Calcular novo tamanho do círculo de contagem
                const startSize = circleData.size * 2.5;
                const targetSize = circleData.size;
                const newSize = startSize - (startSize - targetSize) * progress;
                
                // Atualizar tamanho do círculo de contagem
                circleData.countdownElement.style.width = newSize + 'px';
                circleData.countdownElement.style.height = newSize + 'px';
                
                // Centralizar o círculo
                circleData.countdownElement.style.left = (circleData.position.x - newSize / 2) + 'px';
                circleData.countdownElement.style.top = (circleData.position.y - newSize / 2) + 'px';
                
                // Tocar o som de batida a cada porcentagem do tempo (ajustada pelo nível)
                const knockInterval = circleData.duration <= 1000 ? 400 : 
                                     (circleData.duration <= 1500 ? 450 : 
                                     (circleData.duration <= 2000 ? 500 : 
                                     (circleData.duration <= 3000 ? 600 : 700)));
                                    
                if (Math.floor(elapsed / knockInterval) !== Math.floor((elapsed - 16) / knockInterval)) {
                    createKnockSound();
                }
                
                // Continuar animação
                requestAnimationFrame(() => animateCountdown(circleNumber));
            } else if (!circleData.clicked) {
                // Tempo esgotado, marcar como errado
                circleData.countdownElement.remove();
                circleData.element.style.opacity = '0.4';
                
                // Se era o próximo círculo a ser clicado, avançar para o próximo
                if (circleNumber === nextClickNumber) {
                    nextClickNumber++;
                    updateCircleHighlights(); // Atualizar destaque visual
                }
                
                // Mostrar indicador de erro
                showResultIndicator(circleData.position.x, circleData.position.y, 'miss');
                createFailSound();
                
                // Remover dos círculos ativos
                delete activeCircles[circleNumber];
                
                // Finalizar o jogo como falha
                gameOver();
            }
        }
        
        // Mostrar indicador de resultado (perfect, good, miss)
        function showResultIndicator(x, y, result) {
            const indicator = document.createElement('div');
            indicator.className = `result-indicator ${result}`;
            
            if (result === 'perfect') {
                indicator.textContent = 'PERFEITO!';
            } else if (result === 'good') {
                indicator.textContent = 'BOM!';
            } else {
                indicator.textContent = 'ERROU!';
            }
            
            // Ajustar posição com base no tamanho da tela
            const offset = isMobile ? 30 : 50;
            indicator.style.left = (x - offset) + 'px';
            indicator.style.top = (y - offset) + 'px';
            gameContainer.appendChild(indicator);
            
            // Animação de aparecimento
            setTimeout(() => {
                indicator.style.opacity = '1';
                indicator.style.transform = 'translateY(-20px)';
            }, 10);
            
            // Remover após animação
            setTimeout(() => {
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }, 800);
        }
        
        // Desenhar uma linha entre dois pontos
        function drawLine(x1, y1, x2, y2) {
            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            const line = document.createElement('div');
            line.className = 'line';
            line.style.width = distance + 'px';
            line.style.height = '2px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}rad)`;
            
            gameContainer.appendChild(line);
            lineElements.push(line);
        }
        
        // Tratamento do clique no círculo
        function handleCircleClick(event) {
            // Evitar comportamento padrão para garantir funcionamento em touch devices
            event.preventDefault();
            event.stopPropagation();
            
            const clickedNumber = parseInt(event.target.dataset.number);
            
            // Verificar se o círculo está ativo e é o próximo a ser clicado
            if (activeCircles[clickedNumber] && !activeCircles[clickedNumber].clicked && clickedNumber === nextClickNumber) {
                const circleData = activeCircles[clickedNumber];
                circleData.clicked = true;
                
                // Calcular a precisão do clique
                const progress = circleData.progress;
                const hitZoneStart = 1 - currentLevel.hitZoneTolerance * 2;
                const perfectZoneStart = 1 - currentLevel.hitZoneTolerance;
                
                let result, points;
                
                if (progress >= perfectZoneStart && progress <= 1) {
                    // Acerto perfeito (timing perfeito)
                    result = 'perfect';
                    points = 30;
                    createSuccessSound();
                } else if (progress >= hitZoneStart) {
                    // Acerto bom (dentro da zona de acerto)
                    result = 'good';
                    points = 15;
                    createSuccessSound();
                } else {
                    // Acerto ruim (muito cedo)
                    result = 'miss';
                    points = 0;
                    createFailSound();
                    
                    // Finalizar o jogo como falha se clicou cedo demais
                    setTimeout(() => gameOver(), 800);
                }
                
                // Avançar para o próximo número a ser clicado
                nextClickNumber++;
                updateCircleHighlights(); // Atualizar destaque visual
                
                // Atualizar pontuação
                score += points;
                scoreElement.textContent = score;
                
                // Mostrar indicador de resultado
                showResultIndicator(circleData.position.x, circleData.position.y, result);
                
                // Remover elementos visuais com animação
                circleData.countdownElement.style.opacity = '0';
                circleData.countdownElement.style.transform = 'scale(0.5)';
                
                // Remover elementos do DOM após a animação
                setTimeout(() => {
                    circleData.countdownElement.remove();
                    circleData.element.remove();
                }, 300);
                
                // Remover dos círculos ativos
                delete activeCircles[clickedNumber];
                
                // Se foi o último número, encerrar o jogo
                if (result !== 'miss' && clickedNumber === currentLevel.circleCount && Object.keys(activeCircles).length === 0) {
                    setTimeout(() => endGame(true), 1000);
                }
            }
        }
        
        // Finalizar o jogo como falha (Game Over)
        function gameOver() {
            gameRunning = false;
            
            // Limpar todos os timers
            countdownTimers.forEach(timer => clearTimeout(timer));
            if (spawnTimer) clearTimeout(spawnTimer);
            
            // Desativar cliques nos círculos restantes
            Object.values(activeCircles).forEach(circleData => {
                circleData.countdownElement.style.pointerEvents = 'none';
            });
            
            // Criar overlay de Game Over
            const gameOverOverlay = document.createElement('div');
            gameOverOverlay.className = 'game-over';
            gameOverOverlay.innerHTML = `
                <div>GAME OVER</div>
                <span>Sua pontuação: ${score}</span>
                <button id="restart-button">Tentar Novamente</button>
            `;
            gameContainer.appendChild(gameOverOverlay);
            startButton.disabled = false;
            
            // Configurar botão de reinício
            document.getElementById('restart-button').addEventListener('click', () => {
                gameOverOverlay.remove();
                resetGame();
            });
            
            // Som de falha mais suave (apenas um som)
            createFailSound();
        }
        
        // Finalizar o jogo com sucesso
        function endGame(success) {
            gameRunning = false;
            startButton.disabled = false;
            
            if (success) {
                // Substituir o alert por um overlay de sucesso
                const successOverlay = document.createElement('div');
                successOverlay.className = 'success-overlay';
                
                // Pegar o nome do nível atual
                const levelName = levelSelect.options[levelSelect.selectedIndex].text;
                
                successOverlay.innerHTML = `
                    <div class="title">PARABÉNS!</div>
                    <div class="message">Você completou o nível ${levelName}</div>
                    <div class="message">com ${score} pontos!</div>
                    <button id="continue-button">Continuar</button>
                `;
                
                gameContainer.appendChild(successOverlay);
                
                // Tocar som de celebração
                createCelebrationSound();
                
                // Configurar botão de continuar
                document.getElementById('continue-button').addEventListener('click', () => {
                    successOverlay.remove();
                    resetGame();
                });
            }
        }
        
        // Eventos
        startButton.addEventListener('click', startGame);
        document.onkeydown = function(event) {
            if (event.key === 'Enter') {
                startGame();
            }
        };
    </script>
</body>
</html>