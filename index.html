<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Círculos Sequenciais</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #222;
            color: #fff;
            overflow: hidden;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        select, button {
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #333;
            color: #fff;
        }
        
        button {
            background-color: #2a6e2d;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3a8e3d;
        }
        
        button:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            border: 2px solid #444;
            background-color: #000;
            overflow: hidden;
        }
        
        .circle {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #8fe88f;
            cursor: pointer;
            background-color: transparent;
            border: 2px solid rgba(76, 175, 80, 0.7);
            z-index: 10;
            pointer-events: none; /* Desativa cliques no círculo menor */
        }
        
        .countdown-circle {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(76, 175, 80, 0.6);
            background-color: transparent;
            z-index: 5;
            cursor: pointer; /* Torna o círculo maior clicável */
        }
        
        /* Destacar o próximo círculo que deve ser clicado */
        .countdown-circle.next {
            border: 2px solid rgba(255, 255, 100, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
            z-index: 6; /* Prioridade mais alta para o próximo círculo */
        }
        
        /* Desativar círculos que não devem ser clicados ainda */
        .countdown-circle.inactive {
            pointer-events: none;
            opacity: 0.5;
        }
        
        .result-indicator {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
        }
        
        .perfect {
            color: gold;
        }
        
        .good {
            color: #8fe88f;
        }
        
        .miss {
            color: #ff6b6b;
        }
        
        .line {
            position: absolute;
            background-color: rgba(76, 175, 80, 0.4);
            z-index: 1;
            transform-origin: 0 0;
        }
        
        .score-info {
            margin-top: 20px;
            font-size: 18px;
            color: #fff;
        }
        
        .instruction {
            margin-top: 10px;
            font-style: italic;
            color: #aaa;
            max-width: 800px;
            text-align: center;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 32px;
            text-align: center;
        }
        
        .game-over span {
            font-size: 24px;
            margin-top: 20px;
        }
        
        .game-over button {
            margin-top: 20px;
            font-size: 18px;
            padding: 10px 20px;
        }
        
        /* Estilo para o overlay de sucesso */
        .success-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 32px;
            text-align: center;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .success-overlay .title {
            color: gold;
            font-size: 40px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .success-overlay .message {
            color: #8fe88f;
            font-size: 24px;
            margin: 10px 0;
        }
        
        .success-overlay button {
            margin-top: 20px;
            font-size: 18px;
            padding: 10px 20px;
            background-color: #2a6e2d;
        }
        
        .success-overlay button:hover {
            background-color: #3a8e3d;
        }
    </style>
</head>
<body>
    <h1>Jogo de Círculos Sequenciais</h1>
    
    <div class="controls">
        <select id="level-select">
            <option value="easy">Fácil</option>
            <option value="medium">Médio</option>
            <option value="hard">Difícil</option>
            <option value="expert">Especialista</option>
            <option value="insane">Insano</option>
        </select>
        <button id="start-button">Iniciar Jogo</button>
    </div>
    
    <div class="instruction">
        Clique no círculo destacado quando ele se alinhar com o círculo interno! Você deve clicar nos círculos em ordem numérica.
    </div>
    
    <div id="game-container"></div>
    
    <div class="score-info">
        Pontuação: <span id="score">0</span>
    </div>
    
    <script>
        // Configurações do jogo
        const config = {
            easy: {
                circleCount: 10,
                spawnDelay: 1000,
                timeToClick: 2000,
                circleSize: 90,
                hitZoneTolerance: 0.30
            },
            medium: {
                circleCount: 15,
                spawnDelay: 750,
                timeToClick: 1500,
                circleSize: 90,
                hitZoneTolerance: 0.25
            },
            hard: {
                circleCount: 20,
                spawnDelay: 600,
                timeToClick: 1200,
                circleSize: 90,
                hitZoneTolerance: 0.20
            },
            expert: {
                circleCount: 25,
                spawnDelay: 500,
                timeToClick: 1000,
                circleSize: 90,
                hitZoneTolerance: 0.15
            },
            insane: {
                circleCount: 30,
                spawnDelay: 300,
                timeToClick: 600,
                circleSize: 90,
                hitZoneTolerance: 0.10
            }
        };
        
        // Variáveis do jogo
        let gameRunning = false;
        let currentLevel;
        let currentNumber = 0;
        let nextClickNumber = 1; // Novo: rastreia qual número deve ser clicado em seguida
        let score = 0;
        let lastCirclePos = null;
        let circleElements = [];
        let lineElements = [];
        let countdownTimers = [];
        let activeCircles = {};
        let spawnTimer = null;
        
        // Referências aos elementos do DOM
        const gameContainer = document.getElementById('game-container');
        const levelSelect = document.getElementById('level-select');
        const startButton = document.getElementById('start-button');
        const scoreElement = document.getElementById('score');
        
        // Carregar sons usando o Web Audio API para melhor compatibilidade
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let tickBuffer = null;
        let successBuffer = null;
        let failBuffer = null;
        
        // Função para tocar som
        function playSound(buffer) {
            if (!buffer || !audioContext) return;
            
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
        }
        
        // Criar som de batida de porta (toc toc) - SUAVIZADO
        function createKnockSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Usar um som mais suave, com frequência mais alta e volume mais baixo
            oscillator.type = 'sine'; // Onda senoidal é mais suave que outras ondas
            oscillator.frequency.value = 220; // Frequência mais aguda, menos "batida"
            gainNode.gain.value = 0.15; // Volume bem reduzido
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            // Envelope de amplitude mais suave, sem ataque pronunciado
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.02); // Rampa gradual para subir
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1); // Decaimento mais rápido
            
            setTimeout(() => oscillator.stop(), 100); // Som mais curto
        }
        
        // Som de sucesso suavizado
        function createSuccessSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.value = 880; // Frequência mais agradável (Lá)
            gainNode.gain.value = 0.15; // Volume reduzido
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            // Modulação de frequência mais suave
            oscillator.frequency.linearRampToValueAtTime(1320, audioContext.currentTime + 0.1); // Rampa linear em vez de exponencial
            
            // Envelope de amplitude mais suave
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            setTimeout(() => oscillator.stop(), 200);
        }
        
        // Som de falha mais suave
        function createFailSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine'; 
            oscillator.frequency.value = 220; // Frequência mais baixa
            gainNode.gain.value = 0.15; // Volume reduzido
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            
            // Modulação de frequência mais suave
            oscillator.frequency.linearRampToValueAtTime(180, audioContext.currentTime + 0.2);
            
            // Envelope de amplitude mais suave
            gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            setTimeout(() => oscillator.stop(), 300);
        }
        
        // Som de celebração para conclusão de nível
        function createCelebrationSound() {
            if (!audioContext) return;
            
            // Primeiro acorde
            const playChord = (baseFreq, time, duration) => {
                const notes = [1, 1.25, 1.5]; // Intervalos para formar um acorde maior
                
                notes.forEach(interval => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * interval;
                    gain.gain.value = 0.1; // Volume mais baixo para cada nota do acorde
                    
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    // Envelopes mais suaves
                    gain.gain.setValueAtTime(0, audioContext.currentTime + time);
                    gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + time + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + time + duration);
                    
                    osc.start(audioContext.currentTime + time);
                    osc.stop(audioContext.currentTime + time + duration);
                });
            };
            
            // Tocar uma sequência de acordes ascendentes com volumes mais baixos e mais suaves
            playChord(440, 0, 0.3);    // Lá
            playChord(523.25, 0.25, 0.3); // Dó
            playChord(659.25, 0.5, 0.6);  // Mi (mais longo)
        }
        
        // Iniciar o jogo
        function startGame() {
            // Iniciar contexto de áudio se necessário
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Reset do jogo
            resetGame();
            
            // Configurar o nível
            currentLevel = config[levelSelect.value];
            
            // Marcar o jogo como em execução
            gameRunning = true;
            startButton.disabled = true;
            
            // Redefinir o número para o próximo clique
            nextClickNumber = 1;
            
            // Iniciar o spawn de círculos
            spawnCircle();
        }
        
        // Resetar o jogo
        function resetGame() {
            gameContainer.innerHTML = '';
            circleElements = [];
            lineElements = [];
            currentNumber = 0;
            nextClickNumber = 1;
            score = 0;
            scoreElement.textContent = score;
            lastCirclePos = null;
            activeCircles = {};
            
            // Limpar todos os timers
            countdownTimers.forEach(timer => clearTimeout(timer));
            countdownTimers = [];
            if (spawnTimer) clearTimeout(spawnTimer);
        }
        
        // Função para atualizar o destaque visual do próximo círculo
        function updateCircleHighlights() {
            // Remover todos os destaques
            document.querySelectorAll('.countdown-circle').forEach(circle => {
                circle.classList.remove('next', 'inactive');
            });
            
            // Adicionar destaque ao próximo círculo e desativar os outros
            document.querySelectorAll('.countdown-circle').forEach(circle => {
                const circleNumber = parseInt(circle.dataset.number);
                if (circleNumber === nextClickNumber) {
                    circle.classList.add('next');
                } else if (circleNumber > nextClickNumber) {
                    circle.classList.add('inactive');
                }
            });
        }
        
        // Gerar um círculo
        function spawnCircle() {
            if (!gameRunning) return;
            
            currentNumber++;
            
            // Posição aleatória (com margem para o círculo caber na tela)
            const margin = currentLevel.circleSize;
            const x = margin + Math.random() * (gameContainer.offsetWidth - 2 * margin);
            const y = margin + Math.random() * (gameContainer.offsetHeight - 2 * margin);
            
            // Criar círculo principal
            const circle = document.createElement('div');
            circle.className = 'circle';
            circle.style.width = currentLevel.circleSize + 'px';
            circle.style.height = currentLevel.circleSize + 'px';
            circle.style.left = (x - currentLevel.circleSize / 2) + 'px';
            circle.style.top = (y - currentLevel.circleSize / 2) + 'px';
            circle.textContent = currentNumber;
            circle.dataset.number = currentNumber;
            gameContainer.appendChild(circle);
            circleElements.push(circle);
            
            // Criar círculo de contagem regressiva (agora clicável)
            const countdownCircle = document.createElement('div');
            countdownCircle.className = 'countdown-circle';
            // Adicionar classe 'inactive' se não for o próximo a ser clicado
            if (currentNumber !== nextClickNumber) {
                countdownCircle.classList.add('inactive');
            } else {
                countdownCircle.classList.add('next');
            }
            
            const countdownSize = currentLevel.circleSize * 2.5;
            countdownCircle.style.width = countdownSize + 'px';
            countdownCircle.style.height = countdownSize + 'px';
            countdownCircle.style.left = (x - countdownSize / 2) + 'px';
            countdownCircle.style.top = (y - countdownSize / 2) + 'px';
            countdownCircle.dataset.number = currentNumber;
            countdownCircle.addEventListener('click', handleCircleClick);
            gameContainer.appendChild(countdownCircle);
            
            // Registrar círculo ativo
            activeCircles[currentNumber] = {
                startTime: Date.now(),
                duration: currentLevel.timeToClick,
                element: circle,
                countdownElement: countdownCircle,
                position: { x, y },
                progress: 0,
                clicked: false
            };
            
            // Desenhar linha
            if (lastCirclePos) {
                drawLine(lastCirclePos.x, lastCirclePos.y, x, y);
            }
            
            // Salvar posição atual para a próxima linha
            lastCirclePos = { x, y };
            
            // Iniciar animação de contagem regressiva
            animateCountdown(currentNumber);
            
            // Tocar som de batida inicial
            createKnockSound();
            
            // Agendar o próximo círculo se não for o último
            if (currentNumber < currentLevel.circleCount) {
                spawnTimer = setTimeout(spawnCircle, currentLevel.spawnDelay);
            } else {
                // Todos os círculos foram gerados, aguardar finalização
                spawnTimer = setTimeout(() => {
                    if (gameRunning) {
                        endGame(true);
                    }
                }, currentLevel.timeToClick + 1000);
            }
        }
        
        // Animar o círculo de contagem regressiva
        function animateCountdown(circleNumber) {
            if (!activeCircles[circleNumber] || !gameRunning) return;
            
            const circleData = activeCircles[circleNumber];
            const now = Date.now();
            const elapsed = now - circleData.startTime;
            const progress = Math.min(elapsed / circleData.duration, 1);
            
            circleData.progress = progress;
            
            if (progress < 1 && !circleData.clicked) {
                // Calcular novo tamanho do círculo de contagem
                const startSize = currentLevel.circleSize * 2.5;
                const targetSize = currentLevel.circleSize;
                const newSize = startSize - (startSize - targetSize) * progress;
                
                // Atualizar tamanho do círculo de contagem
                circleData.countdownElement.style.width = newSize + 'px';
                circleData.countdownElement.style.height = newSize + 'px';
                
                // Centralizar o círculo
                circleData.countdownElement.style.left = (circleData.position.x - newSize / 2) + 'px';
                circleData.countdownElement.style.top = (circleData.position.y - newSize / 2) + 'px';
                
                // Tocar o som de batida a cada porcentagem do tempo (ajustada pelo nível)
                // Aumentei o intervalo para tocar o som com menos frequência
                const knockInterval = circleData.duration <= 1000 ? 400 : 
                                     (circleData.duration <= 1500 ? 450 : 
                                     (circleData.duration <= 2000 ? 500 : 
                                     (circleData.duration <= 3000 ? 600 : 700)));
                                    
                if (Math.floor(elapsed / knockInterval) !== Math.floor((elapsed - 16) / knockInterval)) {
                    createKnockSound();
                }
                
                // Continuar animação
                requestAnimationFrame(() => animateCountdown(circleNumber));
            } else if (!circleData.clicked) {
                // Tempo esgotado, marcar como errado
                circleData.countdownElement.remove();
                circleData.element.style.opacity = '0.4';
                
                // Se era o próximo círculo a ser clicado, avançar para o próximo
                if (circleNumber === nextClickNumber) {
                    nextClickNumber++;
                    updateCircleHighlights(); // Atualizar destaque visual
                }
                
                // Mostrar indicador de erro
                showResultIndicator(circleData.position.x, circleData.position.y, 'miss');
                createFailSound();
                
                // Remover dos círculos ativos
                delete activeCircles[circleNumber];
                
                // Finalizar o jogo como falha
                gameOver();
            }
        }
        
        // Mostrar indicador de resultado (perfect, good, miss)
        function showResultIndicator(x, y, result) {
            const indicator = document.createElement('div');
            indicator.className = `result-indicator ${result}`;
            
            if (result === 'perfect') {
                indicator.textContent = 'PERFEITO!';
            } else if (result === 'good') {
                indicator.textContent = 'BOM!';
            } else {
                indicator.textContent = 'ERROU!';
            }
            
            indicator.style.left = (x - 50) + 'px';
            indicator.style.top = (y - 50) + 'px';
            gameContainer.appendChild(indicator);
            
            // Animação de aparecimento
            setTimeout(() => {
                indicator.style.opacity = '1';
                indicator.style.transform = 'translateY(-20px)';
            }, 10);
            
            // Remover após animação
            setTimeout(() => {
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }, 800);
        }
        
        // Desenhar uma linha entre dois pontos
        function drawLine(x1, y1, x2, y2) {
            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            const line = document.createElement('div');
            line.className = 'line';
            line.style.width = distance + 'px';
            line.style.height = '2px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}rad)`;
            
            gameContainer.appendChild(line);
            lineElements.push(line);
        }
        
        // Tratamento do clique no círculo
        function handleCircleClick(event) {
            const clickedNumber = parseInt(event.target.dataset.number);
            
            // Verificar se o círculo está ativo e é o próximo a ser clicado
            if (activeCircles[clickedNumber] && !activeCircles[clickedNumber].clicked && clickedNumber === nextClickNumber) {
                const circleData = activeCircles[clickedNumber];
                circleData.clicked = true;
                
                // Calcular a precisão do clique
                const progress = circleData.progress;
                const hitZoneStart = 1 - currentLevel.hitZoneTolerance * 2;
                const perfectZoneStart = 1 - currentLevel.hitZoneTolerance;
                
                let result, points;
                
                if (progress >= perfectZoneStart && progress <= 1) {
                    // Acerto perfeito (timing perfeito)
                    result = 'perfect';
                    points = 30;
                    createSuccessSound();
                } else if (progress >= hitZoneStart) {
                    // Acerto bom (dentro da zona de acerto)
                    result = 'good';
                    points = 15;
                    createSuccessSound();
                } else {
                    // Acerto ruim (muito cedo)
                    result = 'miss';
                    points = 0;
                    createFailSound();
                    
                    // Finalizar o jogo como falha se clicou cedo demais
                    setTimeout(() => gameOver(), 800);
                }
                
                // Avançar para o próximo número a ser clicado
                nextClickNumber++;
                updateCircleHighlights(); // Atualizar destaque visual
                
                // Atualizar pontuação
                score += points;
                scoreElement.textContent = score;
                
                // Mostrar indicador de resultado
                showResultIndicator(circleData.position.x, circleData.position.y, result);
                
                // Remover elementos visuais
                circleData.countdownElement.remove();
                
                if (result === 'perfect') {
                    circleData.element.style.borderColor = 'gold';
                    circleData.element.style.color = 'gold';
                } else if (result === 'good') {
                    circleData.element.style.borderColor = '#8fe88f';
                    circleData.element.style.borderWidth = '3px';
                } else {
                    circleData.element.style.opacity = '0.4';
                    circleData.element.style.borderColor = '#ff6b6b';
                }
                
                // Remover dos círculos ativos
                delete activeCircles[clickedNumber];
                
                // Se foi o último número, encerrar o jogo
                if (result !== 'miss' && clickedNumber === currentLevel.circleCount && Object.keys(activeCircles).length === 0) {
                    setTimeout(() => endGame(true), 1000);
                }
            }
        }
        
        // Finalizar o jogo como falha (Game Over)
        function gameOver() {
            gameRunning = false;
            
            // Limpar todos os timers
            countdownTimers.forEach(timer => clearTimeout(timer));
            if (spawnTimer) clearTimeout(spawnTimer);
            
            // Desativar cliques nos círculos restantes
            Object.values(activeCircles).forEach(circleData => {
                circleData.countdownElement.style.pointerEvents = 'none';
            });
            
            // Criar overlay de Game Over
            const gameOverOverlay = document.createElement('div');
            gameOverOverlay.className = 'game-over';
            gameOverOverlay.innerHTML = `
                <div>GAME OVER</div>
                <span>Sua pontuação: ${score}</span>
                <button id="restart-button">Tentar Novamente</button>
            `;
            gameContainer.appendChild(gameOverOverlay);
            
            // Configurar botão de reinício
            document.getElementById('restart-button').addEventListener('click', () => {
                gameOverOverlay.remove();
                startButton.disabled = false;
                resetGame();
            });
            
            // Som de falha mais suave (apenas um som)
            createFailSound();
        }
        
        // Finalizar o jogo com sucesso
        function endGame(success) {
            gameRunning = false;
            startButton.disabled = false;
            
            if (success) {
                // Substituir o alert por um overlay de sucesso
                const successOverlay = document.createElement('div');
                successOverlay.className = 'success-overlay';
                
                // Pegar o nome do nível atual
                const levelName = levelSelect.options[levelSelect.selectedIndex].text;
                
                successOverlay.innerHTML = `
                    <div class="title">PARABÉNS!</div>
                    <div class="message">Você completou o nível ${levelName}</div>
                    <div class="message">com ${score} pontos!</div>
                    <button id="continue-button">Continuar</button>
                `;
                
                gameContainer.appendChild(successOverlay);
                
                // Tocar som de celebração
                createCelebrationSound();
                
                // Configurar botão de continuar
                document.getElementById('continue-button').addEventListener('click', () => {
                    successOverlay.remove();
                    resetGame();
                });
            }
        }
        
        // Eventos
        startButton.addEventListener('click', startGame);
        document.onkeydown = function(event) {
            if (event.key === 'Enter') {
                startGame();
            }
        };
    </script>
</body>
</html>